"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
class BodySchemaParser {
    constructor(ajv, apiDoc) {
        this.ajv = ajv;
        this._apiDoc = apiDoc;
    }
    parse(path, pathSchema, contentType) {
        var _a, _b;
        // TODO should return OpenAPIV3.SchemaObject instead
        let schemaRequestBody = pathSchema.requestBody;
        if ((_a = schemaRequestBody) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('$ref')) {
            // TODO use ajv.getSchema instead
            const ref = schemaRequestBody.$ref;
            const id = ref.replace(/^.+\//i, '');
            schemaRequestBody = this._apiDoc.components.requestBodies[id];
        }
        const requestBody = schemaRequestBody;
        if ((_b = requestBody) === null || _b === void 0 ? void 0 : _b.hasOwnProperty('content')) {
            return this.toSchema(path, contentType, requestBody);
            // if (requestBody.required) required.push('body');
        }
        return {};
    }
    toSchema(path, contentType, requestBody) {
        var _a;
        if (requestBody.content) {
            let content = null;
            for (const type of contentType.equivalents()) {
                content = requestBody.content[type];
                if (content)
                    break;
            }
            if (!content) {
                const msg = contentType.contentType === 'not_provided'
                    ? 'media type not specified'
                    : `unsupported media type ${contentType.contentType}`;
                throw util_1.validationError(415, path, msg);
            }
            const schema = this.cleanseContentSchema(contentType, requestBody);
            return _a = (schema !== null && schema !== void 0 ? schema : content.schema), (_a !== null && _a !== void 0 ? _a : {});
        }
        return {};
    }
    cleanseContentSchema(contentType, requestBody) {
        var _a, _b;
        const bodyContentSchema = requestBody.content[contentType.withoutBoundary] &&
            requestBody.content[contentType.withoutBoundary].schema;
        let bodyContentRefSchema = null;
        if (bodyContentSchema && '$ref' in bodyContentSchema) {
            const resolved = this.ajv.getSchema(bodyContentSchema.$ref);
            const schema = (_a = resolved) === null || _a === void 0 ? void 0 : _a.schema;
            bodyContentRefSchema = ((_b = schema) === null || _b === void 0 ? void 0 : _b.properties) ? Object.assign({}, schema) : null;
        }
        // handle readonly / required request body refs
        // don't need to copy schema if validator gets its own copy of the api spec
        // currently all middlware i.e. req and res validators share the spec
        const schema = bodyContentRefSchema || bodyContentSchema;
        if (schema && schema.properties) {
            Object.keys(schema.properties).forEach(prop => {
                const propertyValue = schema.properties[prop];
                const required = schema.required;
                if (propertyValue.readOnly && required) {
                    const index = required.indexOf(prop);
                    if (index > -1) {
                        schema.required = required
                            .slice(0, index)
                            .concat(required.slice(index + 1));
                    }
                }
            });
            return schema;
        }
    }
}
exports.BodySchemaParser = BodySchemaParser;
//# sourceMappingURL=body.parse.js.map