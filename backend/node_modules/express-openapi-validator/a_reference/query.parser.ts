import { OpenAPIV3 } from '../src/framework/types';
import { validationError } from '../src/middlewares/util';

const PARAM_TYPE = {
  query: 'query',
  header: 'headers',
  path: 'params',
  cookie: 'cookies',
};

const rxFalse = /^false/i;
const rxTrue = /^true$/i;
const rxLabel = /^\./;

type Schema = OpenAPIV3.ReferenceObject | OpenAPIV3.SchemaObject;
type Parameter = OpenAPIV3.ReferenceObject | OpenAPIV3.ParameterObject;

export class QueryParser {
  private apiDoc: OpenAPIV3.Document;
  private path: string;
  constructor(apiDoc: OpenAPIV3.Document, path: string) {
    this.apiDoc = apiDoc;
    this.path = path;
  }
  public parse(qs: string, query: any, parameters: Parameter[]): any {
    for (const p of parameters) {
      // TODO really dereference
      const parameter = Util.is$Ref(p)
        ? Util.dereference(this.apiDoc, <OpenAPIV3.ReferenceObject>p)
        : <OpenAPIV3.ParameterObject>p;

      this.parseParameter(qs, query, parameter);
    }
  }

  private parseParameter(
    query: string,
    value: any,
    parameter: OpenAPIV3.ParameterObject,
  ): any {
    if ((!query || query === '') && (!value || Object.keys(value).length === 0)) {
      return value;
    }
    Validate.parameterType(this.path, parameter);
    const { name, schema } = Util.normalize(parameter);
    const { explode, style } = parameter;
    const { type } = schema;

    let parsed;
    if (style === 'deepObject') {
      const rx = RegExp('(?:^|&)' + name + '\\[([^\\]]+)\\](?:=([^&]*))?', 'g');
      const result = {};
      let match;
      let hasValue = false;
      while ((match = rx.exec(value))) {
        hasValue = true;
        result[match[1]] = match[2];
      }
      if (hasValue) parsed = result;
    } else if (style === 'form') {
      if (explode && type === 'object') {
        const result = this.objectExploded('&', '=', '&' + value);
        if (result) {
          parsed = {};
          Object.keys(result).forEach(name => {
            if (
              schema.additionalProperties ||
              (schema.properties && schema.properties.hasOwnProperty(name))
            ) {
              parsed[name] = result[name];
            }
          });
        }
      } else if (query.hasOwnProperty(name)) {
        const ar = query[name];
        if (type === 'array') {
          if (explode) {
            parsed = ar;
          } else if (ar.length > 0) {
            parsed = ar[ar.length - 1].split(',');
          }
        } else if (type === 'object') {
          const result = this.objectFlattened(',', ar[ar.length - 1]);
          if (result) parsed = result;
        } else if (ar.length > 0) {
          parsed = ar[ar.length - 1];
        }
      }
    } else if (style === 'label') {
      if (rxLabel.test(value)) {
        if (type === 'array') {
          parsed = value.substr(1).split(explode ? '.' : ',');
        } else if (type === 'object') {
          parsed = explode
            ? this.objectExploded('.', '=', value)
            : this.objectFlattened(',', value.substr(1));
        } else {
          parsed = value.substr(1);
        }
      }
    } else if (style === 'matrix') {
      const rx = RegExp('^;' + name + '(?:=|$)');
      if (type === 'array') {
        if (explode) {
          const result = this.arrayExploded(';', '=', name, value.substr(1));
          if (result) parsed = result;
        } else {
          parsed = value.substr(name.length + 2).split(',');
        }
      } else if (type === 'object') {
        if (explode || rx.test(value)) {
          const result = explode
            ? this.objectExploded(';', '=', value)
            : this.objectFlattened(',', value.substr(name.length + 2));
          if (result) parsed = result;
        }
      } else if (rx.test(value)) {
        parsed = value.substr(name.length + 2);
      }
    } else if (style === 'pipeDelimited') {
      const ar = query[name];
      if (ar.length > 0) {
        parsed = explode ? ar : this.delimited(type, '|', ar[ar.length - 1]);
      }
    } else if (style === 'simple') {
      if (type === 'array') {
        parsed = value.split(',');
      } else if (type === 'object') {
        parsed = explode
          ? this.objectExploded(',', '=', ',' + value)
          : this.objectFlattened(',', value);
      } else {
        parsed = value;
      }
    } else if (style === 'spaceDelimited') {
      const ar = query[name];
      if (ar.length > 0) {
        parsed = explode ? ar : this.delimited(type, ' ', ar[ar.length - 1]);
      }
    }

    // parse array items and object properties
    if (parsed !== undefined) {
      if (type === 'array') {
        const arraySchema = <OpenAPIV3.ArraySchemaObject>schema;
        parsed = parsed.map((v, i) =>
          this.parsePrimitive(this, arraySchema.items, v),
        );
      } else if (type === 'object') {
        Object.keys(parsed).forEach(key => {
          if (schema.properties && schema.properties[key]) {
            parsed[key] = this.parsePrimitive(
              this,
              schema.properties[key],
              parsed[key],
            );
          } else if (typeof schema.additionalProperties === 'object') {
            parsed[key] = this.parsePrimitive(
              this,
              schema.additionalProperties,
              parsed[key],
            );
          }
        });
      } else {
        parsed = this.parsePrimitive(this, schema, parsed);
      }
    } else {
      throw this.error(400, 'The value is not formatted properly');
    }

    return parsed;
  }

  private isObjectExplode(schema) {
    const type = schema.type;
    const reqField = PARAM_TYPE[parameter.in];
    const hasXOf = schema.allOf || schema.oneOf || schema.anyOf;
    const properties = hasXOf
      ? xOfProperties(schema)
      : type === 'object'
      ? Object.keys(schema.properties)
      : [];


    function xOfProperties(schema: Schema): string[] {
      return ['allOf', 'oneOf', 'anyOf'].reduce((acc, key) => {
        if (!schema.hasOwnProperty(key)) {
          return acc;
        } else {
          const foundProperties = schema[key].reduce((acc2, obj) => {
            return obj.type === 'object'
              ? acc2.concat(...Object.keys(obj.properties))
              : acc2;
          }, []);
          return foundProperties.length > 0
            ? acc.concat(...foundProperties)
            : acc;
        }
      }, []);
    }
  }

  arrayExploded(setDelimiter, valueDelimiter, name, value) {
    const ar = value.split(setDelimiter);
    const length = ar.length;
    const result = [];
    for (let i = 0; i < length; i++) {
      const set = ar[i].split(valueDelimiter);
      if (set[0] === name) {
        result.push(set[1]);
      } else {
        return false;
      }
    }
    return result;
  }

  delimited(type, delimiter, value) {
    if (type === 'array') {
      return value.split(delimiter);
    } else if (type === 'object') {
      return this.objectFlattened(delimiter, value);
    }
  }

  objectExploded(setDelimiter, valueDelimiter, value) {
    const str = 's([^v]+)v([^s]+)?';
    const rx = RegExp(
      str.replace(/v/g, valueDelimiter).replace(/s/g, setDelimiter),
      'g',
    );
    const result = {};
    let match;
    let offset = 0;
    while ((match = rx.exec(value))) {
      result[match[1]] = match[2] || '';
      offset = match.index + match[0].length;
    }
    if (offset !== value.length) return;
    return result;
  }

  objectFlattened(delimiter, value) {
    const result = {};
    const ar = value.split(delimiter);
    const length = ar.length;

    if (length % 2 !== 0) return;
    for (let i = 1; i < length; i += 2) {
      result[ar[i - 1]] = ar[i];
    }
    return result;
  }

  parsePrimitive(parameter, schema, value) {
    if (!value) {
      if (parameter.allowEmptyValue) return null; //new Value(value, { serialize: false, validate: false });
      throw this.error(400, 'Empty value not allowed');
    } else if (schema.type === 'boolean') {
      if (rxTrue.test(value)) return true;
      if (rxFalse.test(value)) return false;
      throw this.error(400, 'Expected "true" or "false". Received: ' + value);
    } else if (schema.type === 'integer') {
      const num = +value;
      if (!isNaN(num)) return num;
      throw this.error(400, 'Expected an integer. Received: ' + value);
    } else if (schema.type === 'number') {
      const num = +value;
      if (!isNaN(num)) return num;
      throw this.error(400, 'Expected a number. Received: ' + value);
    } else if (schema.type === 'string') {
      return value;
    }

    return value;
  }

  error(status: number, message: string) {
    return validationError(status, this.path, message);
  }
}

class Util {
  public static is$Ref(parameter: Parameter): boolean {
    return parameter.hasOwnProperty('$ref');
  }
  public static dereference(
    apiDocs: OpenAPIV3.Document,
    parameter: OpenAPIV3.ReferenceObject,
  ): OpenAPIV3.ParameterObject {
    const id = parameter.$ref.replace(/^.+\//i, '');
    // TODO use ajv.getSchema. double nested $ref may later fail
    return <OpenAPIV3.ParameterObject>apiDocs.components.parameters[id];
  }

  public static normalize(
    parameter: OpenAPIV3.ParameterObject,
  ): {
    name: string;
    schema: OpenAPIV3.SchemaObject;
  } {
    // TODO dereference the schema to guarantee a SchemaObjecxt!
    let schema = parameter.schema;
    if (!schema) {
      const contentType = Object.keys(parameter.content)[0];
      schema = parameter.content?.[contentType]?.schema;
    }
    const name =
      parameter.in === 'header' ? parameter.name.toLowerCase() : parameter.name;
    return { name, schema: <OpenAPIV3.SchemaObject>schema };
  }

  public static hasSchemaObject(schema: Schema): boolean {
    const schemaHasObject = schema => {
      if (!schema) return false;
      const { type, allOf, oneOf, anyOf } = schema;
      return (
        type === 'object' ||
        [].concat(allOf, oneOf, anyOf).some(schemaHasObject)
      );
    };
    return schemaHasObject(schema);
  }
}

class Validate {
  public static parameterType(
    path: string,
    parameter: OpenAPIV3.ParameterObject,
  ): void {
    const isKnownType = PARAM_TYPE[parameter.in];
    if (!isKnownType) {
      const message = `Parameter 'in' has incorrect value '${parameter.in}' for [${parameter.name}]`;
      throw validationError(400, path, message);
    }

    const hasSchema = () => {
      const contentType =
        parameter.content && Object.keys(parameter.content)[0];
      return !parameter.schema || !parameter.content?.[contentType]?.schema;
    };

    if (!hasSchema()) {
      const message = `No available parameter in 'schema' or 'content' for [${parameter.name}]`;
      throw validationError(400, path, message);
    }
  }

  public static arrayDelimiter(
    path: string,
    delimiter: string,
    parameter: OpenAPIV3.ParameterObject,
  ): void {
    if (!delimiter) {
      const message = `Parameter 'style' has incorrect value '${parameter.style}' for [${parameter.name}]`;
      throw validationError(400, path, message);
    }
  }
}
